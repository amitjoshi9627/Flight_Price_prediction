# -*- coding: utf-8 -*-
"""Flight_Price_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17Tm9Vjg1H880Vhs5d5MQsL8eSQ_Jurpp
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
plt.rcParams['figure.figsize'] = (12,6)

# importing training data
data = pd.read_excel('Data_Train.xlsx')

# checking the data
data.head(5)

# information about data
data.info()

"""**Some Exploratory Data Analysis**"""

sns.distplot(data['Price'],kde = False,bins = 30)

sns.barplot(x = 'Price',y = 'Airline',data = data)

sns.countplot(y = 'Airline',data = data)

sns.barplot(x = 'Price',y = 'Source',data = data)

sns.barplot(x = 'Price',y = 'Destination',data = data)

sns.countplot(y = 'Source',data = data)

sns.countplot(y = 'Destination',data = data)

plt.figure(figsize = (14,8))
sns.boxplot(x = 'Price', y = 'Airline', data = data)

sns.countplot(y = 'Total_Stops',data = data)

data[data['Total_Stops'] == '4 stops']

sns.boxplot(x = 'Price',y = 'Total_Stops', data = data)

# importing testing data

test = pd.read_excel('Test_set.xlsx')

test.head()

sum(data['Airline'].isnull())

sum(data['Total_Stops'].isnull())

data[data['Total_Stops'].isnull()]

data[(data['Source'] == 'Delhi') & (data['Destination'] == 'Cochin') & (data['Airline'] == 'Air India') & (data['Duration'] == '23h 40m') & (data['Price'] == 7480)]

data = data.drop(data.index[9039],axis = 0)

data.iloc[9039]

sum(data['Route'].isnull())

sum(data['Arrival_Time'].isnull())

sum(data['Price'].isnull())

# Splitting X and y from data 
X = data.drop('Price',axis = 1)

y = data['Price'].astype('float32')

X['Additional_Info'] = X['Additional_Info'].replace({'No Info':'No info'})
test['Additional_Info'] = test['Additional_Info'].replace({'No Info':'No info'})

X['Total_Stops'] = X['Total_Stops'].apply(lambda x: int(x[0]) if x[0]!='n' else 0)

test['Total_Stops'] = test['Total_Stops'].apply(lambda x: int(x[0]) if x[0]!='n' else 0)

"""***Let's do some Feature Engineering***"""

# Creating Date and Month column

X['Date'] = X['Date_of_Journey'].apply(lambda x: int(x.split('/')[0]))
X['Month'] = X['Date_of_Journey'].apply(lambda x: int(x.split('/')[1]))

test['Date'] = test['Date_of_Journey'].apply(lambda x: int(x.split('/')[0]))
test['Month'] = test['Date_of_Journey'].apply(lambda x: int(x.split('/')[1]))

# Creating a column whether a flight was overnight?

X['Overnight_flight'] = X['Arrival_Time'].apply(lambda x: 1 if len(x) > 5 else 0)

test['Overnight_flight'] = test['Arrival_Time'].apply(lambda x: 1 if len(x) > 5 else 0)

# Creating Day of week column

X['Date_of_Journey'] = X['Date_of_Journey'].apply(lambda x: x[-4:]+'-'+x[-7:-5]+'-'+x[-10:-8])
X['Day_of_Week'] = pd.to_datetime(X['Date_of_Journey']).dt.dayofweek

test['Date_of_Journey'] = test['Date_of_Journey'].apply(lambda x: x[-4:]+'-'+x[-7:-5]+'-'+x[-10:-8])
test['Day_of_Week'] = pd.to_datetime(test['Date_of_Journey']).dt.dayofweek

# merging Sparse column into one

X['Airline'] = X['Airline'].replace({'Vistara Premium economy':'Trujet', 'Jet Airways Business':'Trujet','Multiple carriers Premium economy':'Trujet'})
test['Airline'] = test['Airline'].replace({'Vistara Premium economy':'Trujet', 'Jet Airways Business':'Trujet','Multiple carriers Premium economy':'Trujet'})

plt.scatter(y = X['Day_of_Week'],x = y)

# As number of counts for stops are very less we will merge 3 stops and 4 stops

X['Total_Stops'] = X['Total_Stops'].replace({4:3})
test['Total_Stops'] = test['Total_Stops'].replace({4:3})

"""**Dropping Unnecessary features after doing feature engineering**"""

X = X.drop(['Date_of_Journey','Route','Additional_Info'],axis = 1)
test = test.drop(['Date_of_Journey','Route','Additional_Info'],axis = 1)

X.head()

cat_col = ['Airline', 'Source', 'Destination']

from sklearn.preprocessing import LabelEncoder

for cat in cat_col:
    encoder = LabelEncoder()
    X[cat] = encoder.fit_transform(X[cat])
    test[cat] = encoder.transform(test[cat])

# Convert Time to hour.
def time_to_hour(time):
    if 'h' in time:
        index_h = time.index('h')
        hour = int(time[:index_h]) 
        minute = 0
    else:
        hour = 0
        minute = int(time[:-1])
    
    if len(time) > 4:
        minute = int(time[-3:-1])
        
    return hour + minute / 60

# Formatting Duration in hours
X['Duration'] = X['Duration'].apply(time_to_hour)
test['Duration'] = test['Duration'].apply(time_to_hour)

# Formatting Departure Time in hours
X['Dep_Time'] = X['Dep_Time'].apply(lambda x: int(x[:2])+int(x[3:])/60)
test['Dep_Time'] = test['Dep_Time'].apply(lambda x: int(x[:2])+int(x[3:])/60)

test['Arrival_Time'] = test['Arrival_Time'].apply(lambda x: int(x[:2])+int(x[3:5])/60)
X['Arrival_Time'] = X['Arrival_Time'].apply(lambda x: int(x[:2])+int(x[3:5])/60)

X.head()

"""**Now it's time for model Training**"""

from sklearn.model_selection import train_test_split

# Splitting Data into training and evaluation

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size = 0.3,random_state = 101)

from sklearn.tree import DecisionTreeRegressor

dtree = DecisionTreeRegressor(min_samples_split=10)

# fitting the model

dtree.fit(X_train,y_train)

y_pred = dtree.predict(X_test)

from sklearn.metrics import mean_squared_log_error

print("Decision Tree Regressor 1-RMSLE:",1 - mean_squared_log_error(y_test,y_pred)**0.5)

"""**Let's see if this score can be further improved by some other algorithms**"""

from sklearn.svm import SVR

svr = SVR(C = 2000.0,epsilon = 0.1)

svr.fit(X_train,y_train)

y_pred2 = svr.predict(X_test)

print("SVR 1-RMSLE:",1 - mean_squared_log_error(y_test,y_pred2)**0.5)

from sklearn.ensemble import RandomForestRegressor

forest = RandomForestRegressor(n_estimators=100,min_samples_split=12)

forest.fit(X_train,y_train)

y_pred3 = forest.predict(X_test)

print("Random Forest Regressor 1-RMSLE:",1 - mean_squared_log_error(y_test,y_pred3)**0.5)

from sklearn.ensemble import GradientBoostingRegressor

Grad = GradientBoostingRegressor(learning_rate=0.1,n_estimators=100)

Grad.fit(X_train,y_train)

y_pred4 = Grad.predict(X_test)

print("Gradient Boosting Regressor 1-RMSLE:",1 - mean_squared_log_error(y_test,y_pred4)**0.5)

"""After trying many algorithms the best results were given by Random Forest Regressor. So we will select it for our pedictions."""

forest.fit(X_test,y_test)

# Predictions on a sample of data whose real prices are not known

y_predict = forest.predict(test)

y_predict

df = pd.DataFrame(y_predict,columns = ['Price'])

# Storing the prices in Excel format
df.to_excel('answers.xlsx',index = False)

